This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: tmp/, *.log
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
enemy.py
main.py
plan.md
pygame_window_visualization.html
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="enemy.py">
import pygame


class Enemy(pygame.rect.Rect):
    def __init__(self, x, y, width, height, point_value):
        pygame.rect.Rect.__init__(self, x, y, width, height)
        self.point_value = point_value

    def __str__(self):
        return f"X: {self.x}\nY: {self.y}\nWidth: {self.width}\nHeight: {self.height}\nPoint Value: {self.point_value}"
</file>

<file path="pygame_window_visualization.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pygame Window Coordinate Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
    </style>
  </head>
  <body
    class="bg-gray-900 text-gray-200 flex flex-col items-center justify-center min-h-screen p-4"
  >
    <div class="w-full max-w-4xl text-center">
      <h1 class="text-3xl md:text-4xl font-bold text-cyan-400 mb-2">
        Pygame Window Visualizer
      </h1>
      <p class="text-lg text-gray-400 mb-6">
        A reference for Pygame's coordinate system. The origin (0, 0) is at the
        top-left corner.
      </p>
    </div>

    <div
      class="relative bg-gray-800 p-4 sm:p-6 rounded-xl shadow-2xl border border-gray-700"
    >
      <!-- Coordinate Display -->
      <div
        id="coords"
        class="absolute top-2 right-4 text-xl font-mono bg-gray-900 bg-opacity-70 px-3 py-1 rounded-md text-white transition-opacity duration-300 opacity-0 sm:opacity-100"
      >
        (x, y)
      </div>

      <!-- Canvas representing the Pygame window -->
      <canvas
        id="pygame-window"
        width="640"
        height="480"
        class="bg-gray-700 rounded-lg cursor-crosshair"
      ></canvas>

      <!-- Axis Labels -->
      <div
        class="absolute top-4 left-1/2 -translate-x-1/2 text-cyan-400 font-semibold flex items-center gap-2"
      >
        <span>Y increases downwards</span>
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          fill="currentColor"
          class="bi bi-arrow-down"
          viewBox="0 0 16 16"
        >
          <path
            fill-rule="evenodd"
            d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"
          />
        </svg>
      </div>
      <div
        class="absolute top-1/2 -right-4 -translate-y-1/2 -rotate-90 text-cyan-400 font-semibold flex items-center gap-2"
      >
        <span>X increases rightwards</span>
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          fill="currentColor"
          class="bi bi-arrow-down"
          viewBox="0 0 16 16"
        >
          <path
            fill-rule="evenodd"
            d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"
          />
        </svg>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('pygame-window');
      const ctx = canvas.getContext('2d');
      const coordDisplay = document.getElementById('coords');

      const width = canvas.width;
      const height = canvas.height;

      function drawGuides() {
        ctx.clearRect(0, 0, width, height);

        // --- Draw Coordinate Points ---
        const points = [
          { x: 20, y: 20, label: '(0, 0)', align: 'left', base: 'top' },
          {
            x: width - 20,
            y: 20,
            label: `(${width}, 0)`,
            align: 'right',
            base: 'top',
          },
          {
            x: 20,
            y: height - 20,
            label: `(0, ${height})`,
            align: 'left',
            base: 'bottom',
          },
          {
            x: width - 20,
            y: height - 20,
            label: `(${width}, ${height})`,
            align: 'right',
            base: 'bottom',
          },
          {
            x: width / 2,
            y: height / 2,
            label: `(${width / 2}, ${height / 2})`,
            align: 'center',
            base: 'middle',
          },
        ];

        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = '16px "Inter"';

        points.forEach((p) => {
          // Draw circle marker
          ctx.beginPath();
          ctx.arc(
            p.x === 20 ? 0 : p.x === width / 2 ? width / 2 : width,
            p.y === 20 ? 0 : p.y === height / 2 ? height / 2 : height,
            5,
            0,
            2 * Math.PI
          );
          ctx.fillStyle = '#06b6d4'; // cyan-500
          ctx.fill();

          // Draw label
          ctx.fillStyle = 'white';
          ctx.textAlign = p.align;
          ctx.textBaseline = p.base;
          ctx.fillText(p.label, p.x, p.y);
        });

        // --- Draw Center Lines ---
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);

        // Horizontal center
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();

        // Vertical center
        ctx.beginPath();
        ctx.moveTo(width / 2, 0);
        ctx.lineTo(width / 2, height);
        ctx.stroke();

        ctx.setLineDash([]); // Reset line dash
      }

      // --- Event Listeners ---
      canvas.addEventListener('mousemove', (event) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const x = Math.round((event.clientX - rect.left) * scaleX);
        const y = Math.round((event.clientY - rect.top) * scaleY);

        coordDisplay.textContent = `(${x}, ${y})`;
        coordDisplay.style.opacity = '1';
      });

      canvas.addEventListener('mouseleave', () => {
        coordDisplay.textContent = `(x, y)`;
        if (window.innerWidth < 640) {
          coordDisplay.style.opacity = '0';
        }
      });

      // Initial draw
      window.onload = drawGuides;
    </script>
  </body>
</html>
</file>

<file path="plan.md">
## Moving to Object Oriented

We need an Enemy class

What can an Enemy do?

- can shoot
- can die
- should have a point value
- can move
- is a Rect

how to do this?
while creating grid, we need to create new Enemy and based on the current row we define a different point value?

should movement be a separate class? No, cause the movement is not constant throughout the game.

sep 7

- need barriers - just decrease size of barrier
- I'm buront out of this honestly
- increase speed as less enemies on screen - done
- maybe add levels
  - funciton called increase level
  - if all enemies die increase level
  - increase level changes attributes of Enemy objects and re passes them to the game
    - more enemies?
    - enemies closer to player?
    - faster shooting?
    - etc
</file>

<file path="README.md">
# Hotel Hunt

recreation of space invaders in pygame. first time making a game in pygame.
</file>

<file path="main.py">
import pygame
import random
import sys
from enemy import Enemy


pygame.init()
pygame.font.init()
font = pygame.font.SysFont("Arial", 30)

screen_width = 640
screen_height = 480
footer_height = 40
screen = pygame.display.set_mode((screen_width, screen_height))


player_x = screen_width // 2
player_y_top = screen_height - footer_height - 20
player_speed = 2
player_lives = 3
player_lives_triangle_x = 20
player_score = 0
point_val = 0
triangle_color = (255, 255, 255)

clock = pygame.time.Clock()

enemy_width = 40
enemy_height = 30
enemy_bullets = []
enemy_shot_interval = 1000
enemies_that_can_shoot = []
last_enemy_shot_time = 0
spacing = 10
left_margin = 50
right_margin = 50

usable_width = screen_width - left_margin - right_margin
max_enemies = (usable_width + spacing) // (enemy_width + spacing)
# 540 + 10 // 40 + 10 == 11
enemies = []
num_rows = 5
enemy_start_y = 50
enemy_direction = 1
enemy_alive_count = max_enemies * num_rows
enemy_speed = 1
enemy_move_interval = 125 
last_enemy_move_time = 0
for row in range(num_rows):
    row_enemies = []
    for col in range(max_enemies):
        enemy_x = left_margin + col * (enemy_width + spacing)
        enemy_y = enemy_start_y + row * (enemy_height + spacing)
        if row == 0 or row == 1:
            point_val = 30
        elif row == 2 or row == 3:
            point_val = 20
        else:
            point_val = 10
        enemy_rect = Enemy(enemy_x, enemy_y, enemy_width, enemy_height, point_val)
        row_enemies.append(enemy_rect)
    enemies.append(row_enemies)

bullets = []


running = True

decremented45 = False
decremented35 = False
decremented25 = False
decremented15 = False
decremented5 = False


while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE:
                bullets.append(pygame.Rect(player_x, player_y_top, 5, 5))

    current_time = pygame.time.get_ticks()

    # Enemy shooting
    # killed enemies are still shooting
    for col in range(max_enemies):
        for row in reversed(range(len(enemies))):
            if col < len(enemies[row]):
                enemy = enemies[row][col]
                if enemy is not None:
                    enemies_that_can_shoot.append(enemy)
                    break
    if current_time - last_enemy_shot_time > enemy_shot_interval:
        if enemies_that_can_shoot:
            shooter = random.choice(enemies_that_can_shoot)
            enemy_bullets.append(pygame.Rect(shooter.centerx, shooter.bottom, 5, 5))
            last_enemy_shot_time = current_time

    # Player movement
    keys = pygame.key.get_pressed()
    if keys[pygame.K_a]:
        player_x -= player_speed
    if keys[pygame.K_d]:
        player_x += player_speed

    screen.fill((0, 0, 0))

    # Print Player score
    score_surface = font.render(f"{player_score}", True, (255, 255, 255))
    screen.blit(score_surface, (10, 10))

    top_of_triangle = (player_x, screen_height - footer_height - 20)
    bot_left_triangle = (player_x - 10, screen_height - footer_height)
    bot_right_triangle = (player_x + 10, screen_height - footer_height)
    triangle_vertices = [top_of_triangle, bot_left_triangle, bot_right_triangle]

    player = pygame.draw.polygon(screen, triangle_color, triangle_vertices)

    if enemy_alive_count <= 45 and enemy_alive_count > 35 and not decremented45:
        print("here2")
        enemy_move_interval -= 45
        decremented45 = True
    elif enemy_alive_count <= 35 and enemy_alive_count > 25 and not decremented35:
        print("here3")
        enemy_move_interval -= 45
        decremented35 = True
    elif enemy_alive_count <= 25 and enemy_alive_count > 15 and not decremented25:
        print("here4")
        enemy_move_interval -= 45
        decremented25 = True
    elif enemy_alive_count <= 15 and enemy_alive_count > 5 and not decremented15:
        print("here5")
        enemy_move_interval -= 45
        decremented15 = True
    elif enemy_alive_count <= 5 and not decremented5:
        print("here6")
        enemy_move_interval -= 45
        decremented5 = True
    # print("move interval", enemy_move_interval)
    # print("alive count", enemy_alive_count)

    # Enemy movement and reversal
    # print("will move", current_time)
    # print("last enemy move time", last_enemy_move_time)
    # print("enemy_move_interval", enemy_move_interval)
    reverse_needed = False
    if current_time - last_enemy_move_time > enemy_move_interval:
        for row in enemies:
            for enemy in row:
                if enemy is not None:
                    enemy.x += enemy_direction * enemy_speed
        for col in range(max_enemies):
            for row in range(len(enemies)):
                if enemies[row][col] is not None:
                    if (
                        enemies[row][col].bottomleft[0] <= 0
                        or enemies[row][col].bottomright[0] >= screen_width
                    ):
                        reverse_needed = True
        if reverse_needed:
            enemy_direction *= -1
            for nested_row in enemies:
                for enemy in nested_row:
                    if enemy is not None:
                        enemy.y += 5
        last_enemy_move_time = current_time

    # Drawing enemies to screen
    for row in enemies:
        for enemy in row:
            if enemy is not None:
                pygame.draw.rect(screen, (255, 0, 0), enemy)

    # Drawing enemy bullets and damaging player
    for enemy_bullet in list(enemy_bullets):
        enemy_bullet.y += 5
        pygame.draw.rect(screen, (0, 255, 0), enemy_bullet)
        if enemy_bullet.colliderect(player):
            player_lives -= 1
            enemy_bullets.remove(enemy_bullet)
            if player_lives == 0:
                print("GAME OVER!")
                sys.exit()
        if enemy_bullet.y > screen_height or enemy_bullet.y < 0:
            enemy_bullets.remove(enemy_bullet)

    for i in range(player_lives):
        if player_lives > 0:
            life_tri_x = player_lives_triangle_x + (20 * i)
            life_tri_top = (life_tri_x, screen_height - 20)
            life_tri_bot_left = (life_tri_x - 10, screen_height)
            life_tri_bot_right = (life_tri_x + 10, screen_height)
            life_tri_vertices = [life_tri_top, life_tri_bot_left, life_tri_bot_right]
            pygame.draw.polygon(screen, triangle_color, life_tri_vertices)

    # Player shooting and killing enemies
    for bullet in list(bullets):
        bullet.top -= 5
        pygame.draw.rect(screen, (255, 0, 0), bullet)
        if bullet.top > screen_height or bullet.top < 0:
            bullets.remove(bullet)
        for row in range(len(enemies)):
            for col in range(len(enemies[row])):
                if enemies[row][col] is not None:
                    if bullet.colliderect(enemies[row][col]):
                        bullets.remove(bullet)
                        player_score += enemies[row][col].point_value
                        enemy_alive_count -= 1
                        enemies[row][col] = None
                        break

    fps_surface = font.render(f"{str(int(clock.get_fps()))}", True, (255, 255, 255))
    screen.blit(fps_surface, (590, 10))
    pygame.display.flip()

    clock.tick(60)


pygame.quit()
</file>

</files>
